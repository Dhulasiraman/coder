//go:build mage

package main

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"github.com/coder/coder/coderd/database/migrations"
	"github.com/coder/coder/coderd/database/postgres"

	"github.com/magefile/mage/mg"
	dto "github.com/prometheus/client_model/go"
	"github.com/prometheus/common/expfmt"
	"golang.org/x/xerrors"
)

type Gen mg.Namespace

func (Gen) DumpSQL() error {
	dst := filepath.Join(
		"coderd", "database", "dump.sql",
	)

	if destNewer(dst, sourceFilter{"coderd/database", []string{
		`migrations`,
		`\.sql$`,
	}}) {
		return nil
	}

	connection, closeFn, err := postgres.Open()
	if err != nil {
		return err
	}
	defer closeFn()

	db, err := sql.Open("postgres", connection)
	if err != nil {
		return err
	}

	err = migrations.Up(db)
	if err != nil {
		return err
	}
	const minimumPostgreSQLVersion = 13
	hasPGDump := false
	if _, err = exec.LookPath("pg_dump"); err == nil {
		out, err := exec.Command("pg_dump", "--version").Output()
		if err == nil {
			// Parse output:
			// pg_dump (PostgreSQL) 14.5 (Ubuntu 14.5-0ubuntu0.22.04.1)
			parts := strings.Split(string(out), " ")
			if len(parts) > 2 {
				version, err := strconv.Atoi(strings.Split(parts[2], ".")[0])
				if err == nil && version >= minimumPostgreSQLVersion {
					hasPGDump = true
				}
			}
		}
	}

	cmdArgs := []string{
		"pg_dump",
		"--schema-only",
		connection,
		"--no-privileges",
		"--no-owner",

		// We never want to manually generate
		// queries executing against this table.
		"--exclude-table=schema_migrations",
	}

	if !hasPGDump {
		cmdArgs = append([]string{
			"docker",
			"run",
			"--rm",
			"--network=host",
			fmt.Sprintf("postgres:%d", minimumPostgreSQLVersion),
		}, cmdArgs...)
	}
	cmd := exec.Command(cmdArgs[0], cmdArgs[1:]...) //#nosec
	cmd.Env = append(os.Environ(), []string{
		"PGTZ=UTC",
		"PGCLIENTENCODING=UTF8",
	}...)
	var output bytes.Buffer
	cmd.Stdout = &output
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		return err
	}

	for _, sed := range []string{
		// Remove all comments.
		"/^--/d",
		// Public is implicit in the schema.
		"s/ public\\./ /g",
		"s/::public\\./::/g",
		"s/'public\\./'/g",
		// Remove database settings.
		"s/SET .* = .*;//g",
		// Remove select statements. These aren't useful
		// to a reader of the dump.
		"s/SELECT.*;//g",
		// Removes multiple newlines.
		"/^$/N;/^\\n$/D",
	} {
		cmd := exec.Command("sed", "-e", sed)
		cmd.Stdin = bytes.NewReader(output.Bytes())
		output = bytes.Buffer{}
		cmd.Stdout = &output
		cmd.Stderr = os.Stderr
		err = cmd.Run()
		if err != nil {
			return err
		}
	}

	dump := fmt.Sprintf("-- Code generated by 'mage gen:dumpSQL'. DO NOT EDIT.\n%s", output.Bytes())
	err = os.WriteFile(
		dst,
		[]byte(dump), 0o600,
	)
	if err != nil {
		return err
	}
	return nil
}

func (Gen) GoQuerier() error {
	mg.Deps((Gen).DumpSQL)

	dest := filepath.Join("coderd", "database", "querier.go")
	if destNewer(dest, sourceFilter{"coderd/database", []string{
		`dump.sql$`,
		`sqlc.yaml$`,
		`\.sql$`,
	}}) {
		return nil
	}

	return shell("./coderd/database/generate.sh").run()
}

func (Gen) ProvisionerProto() error {
	var (
		dest   = filepath.Join("provisionersdk", "proto", "provisioner.pb.go")
		source = filepath.Join("provisionersdk", "proto", "provisioner.proto")
	)
	if destNewer(
		dest, sourceFilter{source, nil},
	) {
		return nil
	}

	return shell(`
		protoc \
		--go_out=. \
		--go_opt=paths=source_relative \
		--go-drpc_out=. \
		--go-drpc_opt=paths=source_relative \
		%s \
	`, source).run()
}

func (Gen) ProvisionerdProto() error {
	var (
		dest   = filepath.Join("provisionerd", "proto", "provisionerd.pb.go")
		source = filepath.Join("provisionerd", "proto", "provisionerd.proto")
	)
	if destNewer(
		dest, sourceFilter{source, nil},
	) {
		return nil
	}

	return shell(`
		protoc \
		--go_out=. \
		--go_opt=paths=source_relative \
		--go-drpc_out=. \
		--go-drpc_opt=paths=source_relative \
		%s \
	`, source).run()
}

func (Gen) TypesGenerated() error {
	dest := filepath.Join("site/src/api/typesGenerated.ts")
	if destNewer(
		dest, sourceFilter{"codersdk", []string{`\.go$`}},
	) {
		return nil
	}

	destFi, err := os.OpenFile(dest, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o600)
	if err != nil {
		return err
	}
	defer destFi.Close()

	c := goRun("./scripts/apitypings/main.go")
	c.Stdout = destFi
	c.Stderr = os.Stderr
	err = c.run()
	if err != nil {
		return err
	}

	return shell("yarn format:types").cd("site").run()
}

func (Gen) PrometheusDocs() error {
	var (
		metricsFile = "scripts/metricsdocgen/metrics"
		dest        = "docs/admin/prometheus.md"
	)

	if destNewer(dest, sourceFilter{"scripts/metricsdocgen", nil}) {
		return nil
	}

	metrics, err := readMetrics(metricsFile)
	if err != nil {
		return xerrors.Errorf("can't read metrics: %w", err)
	}

	doc, err := readPrometheusDoc(dest)
	if err != nil {
		return xerrors.Errorf("can't read Prometheus doc: %w", err)
	}

	doc, err = updatePrometheusDoc(doc, metrics)
	if err != nil {
		return xerrors.Errorf("can't update Prometheus doc: %w", err)
	}

	err = writePrometheusDoc(dest, doc)
	if err != nil {
		return xerrors.Errorf("can't write updated Prometheus doc: %w", err)
	}

	absDest, err := filepath.Abs(dest)
	if err != nil {
		return err
	}

	return shell(
		"yarn run format:write:only %s", absDest,
	).cd("site").run()
}

func readMetrics(metricsFile string) ([]dto.MetricFamily, error) {
	f, err := os.Open(metricsFile)
	if err != nil {
		return nil, xerrors.New("can't open metrics file")
	}

	var metrics []dto.MetricFamily

	decoder := expfmt.NewDecoder(f, expfmt.FmtProtoText)
	for {
		var m dto.MetricFamily
		err = decoder.Decode(&m)
		if errors.Is(err, io.EOF) {
			break
		} else if err != nil {
			return nil, err
		}
		metrics = append(metrics, m)
	}

	sort.Slice(metrics, func(i, j int) bool {
		return sort.StringsAreSorted([]string{*metrics[i].Name, *metrics[j].Name})
	})
	return metrics, nil
}

func readPrometheusDoc(n string) ([]byte, error) {
	doc, err := os.ReadFile(n)
	if err != nil {
		return nil, err
	}
	return doc, nil
}

func updatePrometheusDoc(doc []byte, metricFamilies []dto.MetricFamily) ([]byte, error) {
	var (
		generatorPrefix = []byte("<!-- Code generated by 'mage gen:prometheusDocs'. DO NOT EDIT -->")
		generatorSuffix = []byte("<!-- End generated by 'mage gen:prometheusDocs'. -->")
	)

	i := bytes.Index(doc, generatorPrefix)
	if i < 0 {
		return nil, xerrors.New("generator prefix tag not found")
	}
	tableStartIndex := i + len(generatorPrefix) + 1

	j := bytes.Index(doc[tableStartIndex:], generatorSuffix)
	if j < 0 {
		return nil, xerrors.New("generator suffix tag not found")
	}
	tableEndIndex := tableStartIndex + j

	var buffer bytes.Buffer
	_, _ = buffer.Write(doc[:tableStartIndex])
	_ = buffer.WriteByte('\n')

	_, _ = buffer.WriteString("| Name | Type | Description | Labels |\n")
	_, _ = buffer.WriteString("| - | - | - | - |\n")
	for _, mf := range metricFamilies {
		_, _ = buffer.WriteString("| ")
		_, _ = buffer.Write([]byte("`" + *mf.Name + "`"))
		_, _ = buffer.WriteString(" | ")
		_, _ = buffer.Write([]byte(strings.ToLower(mf.Type.String())))
		_, _ = buffer.WriteString(" | ")
		if mf.Help != nil {
			_, _ = buffer.Write([]byte(*mf.Help))
		}
		_, _ = buffer.WriteString(" | ")

		labels := map[string]struct{}{}
		metrics := mf.GetMetric()
		for _, m := range metrics {
			for _, label := range m.Label {
				labels["`"+*label.Name+"`"] = struct{}{}
			}
		}

		if len(labels) > 0 {
			_, _ = buffer.WriteString(strings.Join(sortedKeys(labels), " "))
		}

		_, _ = buffer.WriteString(" |\n")
	}

	_ = buffer.WriteByte('\n')
	_, _ = buffer.Write(doc[tableEndIndex:])
	return buffer.Bytes(), nil
}

func writePrometheusDoc(path string, doc []byte) error {
	// G306: Expect WriteFile permissions to be 0600 or less
	/* #nosec G306 */
	err := os.WriteFile(path, doc, 0o644)
	if err != nil {
		return err
	}
	return nil
}

func sortedKeys(m map[string]struct{}) []string {
	var keys []string
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

func (Gen) All() {
	mg.Deps(
		(Gen).GoQuerier, (Gen).DumpSQL,
		(Gen).ProvisionerProto, (Gen).ProvisionerdProto,
		(Gen).TypesGenerated,
	)
}
